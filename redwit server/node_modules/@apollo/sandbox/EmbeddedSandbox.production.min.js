'use strict';

var graphqlWs = require('graphql-ws');
var subscriptionsTransportWs = require('subscriptions-transport-ws');

// URL for any embedded Explorer iframe
const EMBEDDABLE_SANDBOX_URL = 'https://sandbox.embed.apollographql.com/sandbox/explorer'; // Message types for Explorer state
const SCHEMA_ERROR = 'SchemaError';
const SCHEMA_RESPONSE = 'SchemaResponse'; // Message types for queries and mutations

const EXPLORER_QUERY_MUTATION_REQUEST = 'ExplorerRequest';
const EXPLORER_QUERY_MUTATION_RESPONSE = 'ExplorerResponse'; // Message types for subscriptions

const EXPLORER_SUBSCRIPTION_REQUEST = 'ExplorerSubscriptionRequest';
const EXPLORER_SUBSCRIPTION_RESPONSE = 'ExplorerSubscriptionResponse';
const EXPLORER_SUBSCRIPTION_TERMINATION = 'ExplorerSubscriptionTermination';
const EXPLORER_SET_SOCKET_ERROR = 'ExplorerSetSocketError';
const EXPLORER_SET_SOCKET_STATUS = 'ExplorerSetSocketStatus';
const IFRAME_DOM_ID = uniqueId => `apollo-embed-${uniqueId}`; // Message types for authentication

const EXPLORER_LISTENING_FOR_HANDSHAKE = 'ExplorerListeningForHandshake';
const HANDSHAKE_RESPONSE = 'HandshakeResponse';
const SET_PARTIAL_AUTHENTICATION_TOKEN_FOR_PARENT = 'SetPartialAuthenticationTokenForParent';
const TRIGGER_LOGOUT_IN_PARENT = 'TriggerLogoutInParent';
const EXPLORER_LISTENING_FOR_PARTIAL_TOKEN = 'ExplorerListeningForPartialToken';
const PARTIAL_AUTHENTICATION_TOKEN_RESPONSE = 'PartialAuthenticationTokenResponse';
const INTROSPECTION_QUERY_WITH_HEADERS = 'IntrospectionQueryWithHeaders';
const PARENT_LOGOUT_SUCCESS = 'ParentLogoutSuccess';

const defaultHandleRequest = ({
  includeCookies
}) => {
  const handleRequestWithCookiePref = (endpointUrl, options) => fetch(endpointUrl, Object.assign(Object.assign({}, options), includeCookies ? {
    credentials: 'include'
  } : {}));

  return handleRequestWithCookiePref;
};

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// to each request's headers if not present

function getHeadersWithContentType(headers) {
  const headersWithContentType = headers !== null && headers !== void 0 ? headers : {};

  if (Object.keys(headersWithContentType).every(key => key.toLowerCase() !== 'content-type')) {
    headersWithContentType['content-type'] = 'application/json';
  }

  return headersWithContentType;
}

function sendPostMessageToEmbed({
  message,
  embeddedIFrameElement,
  embedUrl
}) {
  var _a;

  (_a = embeddedIFrameElement === null || embeddedIFrameElement === void 0 ? void 0 : embeddedIFrameElement.contentWindow) === null || _a === void 0 ? void 0 : _a.postMessage(message, embedUrl);
} // | MessageEvent<{
//     name: typeof EXPLORER_LISTENING_FOR_HANDSHAKE;
//   }>
// | MessageEvent<{
//     name: typeof EXPLORER_QUERY_MUTATION_REQUEST;
//     operationName?: string;
//     operation: string;
//     operationId: string;
//     variables?: Record<string, string>;
//     headers?: Record<string, string>;
//     sandboxEndpointUrl?: string;
//   }>
// | MessageEvent<{
//     name: typeof EXPLORER_SUBSCRIPTION_REQUEST;
//     operationId: string;
//     operation: string;
//     variables?: Record<string, string>;
//     operationName?: string;
//     headers?: Record<string, string>;
//     subscriptionUrl: string;
//     protocol: GraphQLSubscriptionLibrary;
//   }>
// | MessageEvent<{
//     name: typeof EXPLORER_SUBSCRIPTION_TERMINATION;
//     operationId: string;
//   }>
// | MessageEvent<{
//     name: typeof EXPLORER_LISTENING_FOR_SCHEMA;
//   }>
// | MessageEvent<{
//     name: typeof SET_PARTIAL_AUTHENTICATION_TOKEN_FOR_PARENT;
//     localStorageKey: string;
//     partialToken: string;
//   }>
// | MessageEvent<{
//     name: typeof TRIGGER_LOGOUT_IN_PARENT;
//     localStorageKey: string;
//   }>
// | MessageEvent<{
//     name: typeof EXPLORER_LISTENING_FOR_PARTIAL_TOKEN;
//     localStorageKey?: string;
//   }>
// | MessageEvent<{
//     name: typeof INTROSPECTION_QUERY_WITH_HEADERS;
//     introspectionRequestBody: string;
//     introspectionRequestHeaders: Record<string, string>;
//     sandboxEndpointUrl?: string;
//   }>;

function executeOperation({
  endpointUrl,
  handleRequest,
  operation,
  operationName,
  variables,
  headers,
  embeddedIFrameElement,
  operationId,
  embedUrl
}) {
  return handleRequest(endpointUrl, {
    method: 'POST',
    headers: getHeadersWithContentType(headers),
    body: JSON.stringify({
      query: operation,
      variables,
      operationName
    })
  }).then(response => __awaiter(this, void 0, void 0, function* () {
    const json = yield response.json();
    const responseHeaders = {};
    response.headers.forEach((value, key) => {
      responseHeaders[key] = value;
    });
    sendPostMessageToEmbed({
      message: {
        // Include the same operation ID in the response message's name
        // so the Explorer knows which operation it's associated with
        name: EXPLORER_QUERY_MUTATION_RESPONSE,
        operationId,
        response: Object.assign(Object.assign({}, json), {
          status: response.status,
          headers: responseHeaders
        })
      },
      embeddedIFrameElement,
      embedUrl
    });
  })).catch(response => {
    sendPostMessageToEmbed({
      message: {
        // Include the same operation ID in the response message's name
        // so the Explorer knows which operation it's associated with
        name: EXPLORER_QUERY_MUTATION_RESPONSE,
        operationId,
        response: {
          error: Object.assign({
            message: response.message
          }, response.stack ? {
            stack: response.stack
          } : {})
        }
      },
      embeddedIFrameElement,
      embedUrl
    });
  });
}
function executeIntrospectionRequest({
  endpointUrl,
  headers,
  introspectionRequestBody,
  embeddedIFrameElement
}) {
  const {
    query,
    operationName
  } = JSON.parse(introspectionRequestBody);
  return fetch(endpointUrl, {
    method: 'POST',
    headers: getHeadersWithContentType(headers),
    body: JSON.stringify({
      query,
      operationName
    })
  }).then(response => response.json()).then(response => {
    if (response.errors && response.errors.length) {
      sendPostMessageToEmbed({
        message: {
          // Include the same operation ID in the response message's name
          // so the Explorer knows which operation it's associated with
          name: SCHEMA_ERROR,
          errors: response.errors
        },
        embeddedIFrameElement,
        embedUrl: EMBEDDABLE_SANDBOX_URL
      });
    }

    sendPostMessageToEmbed({
      message: {
        // Include the same operation ID in the response message's name
        // so the Explorer knows which operation it's associated with
        name: SCHEMA_RESPONSE,
        schema: response.data
      },
      embeddedIFrameElement,
      embedUrl: EMBEDDABLE_SANDBOX_URL
    });
  }).catch(error => {
    sendPostMessageToEmbed({
      message: {
        // Include the same operation ID in the response message's name
        // so the Explorer knows which operation it's associated with
        name: SCHEMA_ERROR,
        error: error
      },
      embeddedIFrameElement,
      embedUrl: EMBEDDABLE_SANDBOX_URL
    });
  });
}
const handleAuthenticationPostMessage = ({
  event,
  embeddedIFrameElement,
  embedUrl
}) => {
  const {
    data
  } = event; // When the embed authenticates, save the partial token in local storage

  if (data.name === SET_PARTIAL_AUTHENTICATION_TOKEN_FOR_PARENT) {
    const partialEmbedApiKeysString = window.localStorage.getItem('apolloStudioEmbeddedExplorerEncodedApiKey');
    const partialEmbedApiKeys = partialEmbedApiKeysString ? JSON.parse(partialEmbedApiKeysString) : {};
    partialEmbedApiKeys[data.localStorageKey] = data.partialToken;
    window.localStorage.setItem('apolloStudioEmbeddedExplorerEncodedApiKey', JSON.stringify(partialEmbedApiKeys));
  } // When the embed logs out, remove the partial token in local storage


  if (data.name === TRIGGER_LOGOUT_IN_PARENT) {
    const partialEmbedApiKeysString = window.localStorage.getItem('apolloStudioEmbeddedExplorerEncodedApiKey');
    const partialEmbedApiKeys = partialEmbedApiKeysString ? JSON.parse(partialEmbedApiKeysString) : {};
    delete partialEmbedApiKeys[data.localStorageKey];
    window.localStorage.setItem('apolloStudioEmbeddedExplorerEncodedApiKey', JSON.stringify(partialEmbedApiKeys));
    sendPostMessageToEmbed({
      message: {
        name: PARENT_LOGOUT_SUCCESS
      },
      embeddedIFrameElement,
      embedUrl
    });
  }

  if (data.name === EXPLORER_LISTENING_FOR_PARTIAL_TOKEN && data.localStorageKey) {
    const partialEmbedApiKeysString = window.localStorage.getItem('apolloStudioEmbeddedExplorerEncodedApiKey');
    const partialEmbedApiKeys = partialEmbedApiKeysString ? JSON.parse(partialEmbedApiKeysString) : {};

    if (partialEmbedApiKeys && partialEmbedApiKeys[data.localStorageKey]) {
      sendPostMessageToEmbed({
        message: {
          name: PARTIAL_AUTHENTICATION_TOKEN_RESPONSE,
          partialToken: partialEmbedApiKeys[data.localStorageKey]
        },
        embeddedIFrameElement,
        embedUrl
      });
    }
  }
};

function assertUnreachable(x) {
  throw new Error(`Didn't expect to get here ${x}`);
}

class SubscriptionClient {
  constructor(url, headers, protocol) {
    this.unsubscribeFunctions = [];
    this.protocol = protocol;
    this.url = url;
    this.headers = headers;
  }

  get graphWsClient() {
    var _a, _b;

    const client = (_a = this._graphWsClient) !== null && _a !== void 0 ? _a : graphqlWs.createClient({
      url: this.url,
      lazy: true,
      connectionParams: (_b = this.headers) !== null && _b !== void 0 ? _b : {},
      keepAlive: 10000
    });
    this._graphWsClient = client;
    return client;
  }

  get transportSubscriptionClient() {
    var _a, _b;

    const client = (_a = this._transportSubscriptionClient) !== null && _a !== void 0 ? _a : new subscriptionsTransportWs.SubscriptionClient(this.url, {
      reconnect: true,
      lazy: true,
      connectionParams: (_b = this.headers) !== null && _b !== void 0 ? _b : {}
    });
    this._transportSubscriptionClient = client;
    return client;
  }

  onConnected(callback) {
    if (this.protocol === 'graphql-ws') {
      return this.graphWsClient.on('connected', callback);
    }

    if (this.protocol === 'subscriptions-transport-ws') {
      return this.transportSubscriptionClient.onConnected(callback);
    }

    assertUnreachable(this.protocol);
  }

  onConnecting(callback) {
    if (this.protocol === 'graphql-ws') {
      return this.graphWsClient.on('connecting', callback);
    }

    if (this.protocol === 'subscriptions-transport-ws') {
      return this.transportSubscriptionClient.onConnecting(callback);
    }

    assertUnreachable(this.protocol);
  }

  onError(callback) {
    if (this.protocol === 'graphql-ws') {
      return this.graphWsClient.on('error', error => callback(error));
    }

    if (this.protocol === 'subscriptions-transport-ws') {
      return this.transportSubscriptionClient.onError(e => callback(e));
    }

    assertUnreachable(this.protocol);
  }

  onReconnecting(callback) {
    if (this.protocol === 'graphql-ws') {
      return;
    }

    if (this.protocol === 'subscriptions-transport-ws') {
      return this.transportSubscriptionClient.onReconnecting(callback);
    }

    assertUnreachable(this.protocol);
  }

  onReconnected(callback) {
    if (this.protocol === 'graphql-ws') {
      return;
    }

    if (this.protocol === 'subscriptions-transport-ws') {
      return this.transportSubscriptionClient.onReconnected(callback);
    }

    assertUnreachable(this.protocol);
  }

  onDisconnected(callback) {
    if (this.protocol === 'graphql-ws') {
      return this.graphWsClient.on('closed', callback);
    }

    if (this.protocol === 'subscriptions-transport-ws') {
      return this.transportSubscriptionClient.onDisconnected(callback);
    }

    assertUnreachable(this.protocol);
  }

  request(params) {
    return {
      subscribe: subscribeParams => {
        if (this.protocol === 'graphql-ws') {
          this.unsubscribeFunctions.push(this.graphWsClient.subscribe(params, Object.assign(Object.assign({}, subscribeParams), {
            next: data => {
              var _a;

              return (_a = subscribeParams.next) === null || _a === void 0 ? void 0 : _a.call(subscribeParams, data);
            },
            error: error => {
              var _a;

              return (_a = subscribeParams.error) === null || _a === void 0 ? void 0 : _a.call(subscribeParams, error);
            },
            complete: () => {}
          })));
        }

        if (this.protocol === 'subscriptions-transport-ws') {
          return this.transportSubscriptionClient.request(params).subscribe(subscribeParams);
        } else {
          return undefined;
        }
      }
    };
  }

  unsubscribeAll() {
    if (this.protocol === 'graphql-ws') {
      this.unsubscribeFunctions.forEach(off => {
        off();
      });
      this.unsubscribeFunctions = [];
    }

    if (this.protocol === 'subscriptions-transport-ws') {
      return this.transportSubscriptionClient.unsubscribeAll();
    }
  }

}

function setParentSocketError({
  error,
  embeddedIFrameElement,
  embedUrl
}) {
  sendPostMessageToEmbed({
    message: {
      name: EXPLORER_SET_SOCKET_ERROR,
      error
    },
    embeddedIFrameElement,
    embedUrl
  });
}

function setParentSocketStatus({
  status,
  embeddedIFrameElement,
  embedUrl
}) {
  sendPostMessageToEmbed({
    message: {
      name: EXPLORER_SET_SOCKET_STATUS,
      status
    },
    embeddedIFrameElement,
    embedUrl
  });
}

function executeSubscription({
  operation,
  operationName,
  variables,
  headers,
  embeddedIFrameElement,
  operationId,
  embedUrl,
  subscriptionUrl,
  protocol
}) {
  const client = new SubscriptionClient(subscriptionUrl, headers !== null && headers !== void 0 ? headers : {}, protocol);

  const checkForSubscriptionTermination = event => {
    if (event.data.name === EXPLORER_SUBSCRIPTION_TERMINATION) {
      client.unsubscribeAll();
      window.removeEventListener('message', checkForSubscriptionTermination);
    }
  };

  window.addEventListener('message', checkForSubscriptionTermination);
  client.onError(e => setParentSocketError({
    error: JSON.parse(JSON.stringify(e)),
    embeddedIFrameElement,
    embedUrl
  }));
  client.onConnected(() => {
    setParentSocketError({
      error: undefined,
      embeddedIFrameElement,
      embedUrl
    });
    setParentSocketStatus({
      status: 'connected',
      embeddedIFrameElement,
      embedUrl
    });
  });
  client.onReconnected(() => {
    setParentSocketError({
      error: undefined,
      embeddedIFrameElement,
      embedUrl
    });
    setParentSocketStatus({
      status: 'connected',
      embeddedIFrameElement,
      embedUrl
    });
  });
  client.onConnecting(() => setParentSocketStatus({
    status: 'connecting',
    embeddedIFrameElement,
    embedUrl
  }));
  client.onReconnecting(() => setParentSocketStatus({
    status: 'connecting',
    embeddedIFrameElement,
    embedUrl
  }));
  client.onDisconnected(() => setParentSocketStatus({
    status: 'disconnected',
    embeddedIFrameElement,
    embedUrl
  }));
  client.request({
    query: operation,
    variables: variables !== null && variables !== void 0 ? variables : {},
    operationName
  }).subscribe({
    next(data) {
      sendPostMessageToEmbed({
        message: {
          // Include the same operation ID in the response message's name
          // so the Explorer knows which operation it's associated with
          name: EXPLORER_SUBSCRIPTION_RESPONSE,
          operationId,
          response: {
            data
          }
        },
        embeddedIFrameElement,
        embedUrl
      });
    },

    error: error => {
      sendPostMessageToEmbed({
        message: {
          // Include the same operation ID in the response message's name
          // so the Explorer knows which operation it's associated with
          name: EXPLORER_SUBSCRIPTION_RESPONSE,
          operationId,
          response: {
            error: JSON.parse(JSON.stringify(error))
          }
        },
        embeddedIFrameElement,
        embedUrl
      });
    }
  });
  return {
    dispose: () => window.removeEventListener('message', checkForSubscriptionTermination)
  };
}

function setupSandboxEmbedRelay({
  handleRequest,
  embeddedSandboxIFrameElement
}) {
  const embedUrl = EMBEDDABLE_SANDBOX_URL; // Callback definition

  const onPostMessageReceived = event => {
    handleAuthenticationPostMessage({
      event,
      embedUrl,
      embeddedIFrameElement: embeddedSandboxIFrameElement
    }); // Any pm can be listened for here, not just the ones we know the
    // structure of. Some have a data field that is not an object

    const data = typeof event.data === 'object' ? event.data : undefined;

    if (data && 'name' in data) {
      // When embed connects, send a handshake message
      if (data.name === EXPLORER_LISTENING_FOR_HANDSHAKE) {
        sendPostMessageToEmbed({
          message: {
            name: HANDSHAKE_RESPONSE,
            parentHref: window.location.href
          },
          embeddedIFrameElement: embeddedSandboxIFrameElement,
          embedUrl
        });
      }

      if (data.name === INTROSPECTION_QUERY_WITH_HEADERS) {
        const {
          introspectionRequestBody,
          introspectionRequestHeaders,
          sandboxEndpointUrl
        } = data;

        if (sandboxEndpointUrl) {
          executeIntrospectionRequest({
            endpointUrl: sandboxEndpointUrl,
            introspectionRequestBody,
            headers: introspectionRequestHeaders,
            embeddedIFrameElement: embeddedSandboxIFrameElement
          });
        }
      } // Check to see if the posted message indicates that the user is
      // executing a query or mutation or subscription in the Explorer


      const isQueryOrMutation = data.name === EXPLORER_QUERY_MUTATION_REQUEST;
      const isSubscription = data.name === EXPLORER_SUBSCRIPTION_REQUEST; // If the user is executing a query or mutation or subscription...

      if ((isQueryOrMutation || isSubscription) && data.operation && data.operationId) {
        // Extract the operation details from the event.data object
        const {
          operation,
          operationId,
          operationName,
          variables,
          headers,
          endpointUrl,
          // this can be deleted in Fall 2022
          // it is just here to be backwards compatible with old
          // studio versions (service workers)
          sandboxEndpointUrl
        } = data;

        if (isQueryOrMutation && endpointUrl) {
          executeOperation({
            endpointUrl: endpointUrl !== null && endpointUrl !== void 0 ? endpointUrl : sandboxEndpointUrl,
            handleRequest,
            operation,
            operationName,
            variables,
            headers,
            embeddedIFrameElement: embeddedSandboxIFrameElement,
            operationId,
            embedUrl
          });
        } else if (isSubscription) {
          executeSubscription({
            operation,
            operationName,
            variables,
            headers,
            embeddedIFrameElement: embeddedSandboxIFrameElement,
            operationId,
            embedUrl,
            subscriptionUrl: data.subscriptionUrl,
            protocol: data.protocol
          });
        }
      }
    }
  }; // Execute our callback whenever window.postMessage is called


  window.addEventListener('message', onPostMessageReceived);
  return {
    dispose: () => window.removeEventListener('message', onPostMessageReceived)
  };
}

var name = "@apollo/sandbox";
var version = "0.2.1";
var author = "packages@apollographql.com";
var license = "MIT";
var repository = {
	type: "git",
	url: "https://github.com/apollographql/embeddable-explorer"
};
var homepage = "https://github.com/apollographql/embeddable-explorer#readme";
var main = "dist/index.cjs";
var module$1 = "dist/index.mjs";
var typings = "dist/src/index.d.ts";
var engines = {
	node: ">=12.0",
	npm: ">=7.0"
};
var scripts = {
	build: "npm run build:cjs-esm",
	"build:cjs-esm": "rm -rf dist && rollup -c buildHelpers/rollup.cjs-esm.config.js && cp src/index.cjs dist/index.cjs && cp src/react/index.cjs dist/react/index.cjs && node ./buildHelpers/prepareDist.js sandbox",
	"build:umd": "rm -rf dist && rollup -c buildHelpers/rollup.umd.config.js",
	lint: "eslint --ext .js,.jsx,.ts,.tsx .",
	size: "size-limit",
	analyze: "size-limit --why",
	"typescript:check": "tsc --noEmit",
	"prettier:check": "prettier --check .",
	"prettier:fix": "prettier --write ."
};
var husky = {
	hooks: {
		"pre-commit": "npm run lint"
	}
};
var prettier = {
	printWidth: 80,
	semi: true,
	singleQuote: true,
	trailingComma: "es5",
	endOfLine: "auto"
};
var peerDependencies = {
	react: "^16.8.0 || ^17.0.0 || ^18.0.0",
	"react-dom": "^16.8.0 || ^17.0.0 || ^18.0.0"
};
var peerDependenciesMeta = {
	react: {
		optional: true
	},
	"react-dom": {
		optional: true
	}
};
var dependencies = {
	"graphql-ws": "^5.9.0",
	"subscriptions-transport-ws": "^0.11.0"
};
var packageJSON = {
	name: name,
	version: version,
	author: author,
	license: license,
	repository: repository,
	homepage: homepage,
	main: main,
	module: module$1,
	typings: typings,
	engines: engines,
	scripts: scripts,
	husky: husky,
	prettier: prettier,
	"size-limit": [
	{
		path: "dist/index.production.min.js",
		limit: "10 KB"
	},
	{
		path: "dist/index.mjs",
		limit: "10 KB"
	}
],
	peerDependencies: peerDependencies,
	peerDependenciesMeta: peerDependenciesMeta,
	dependencies: dependencies
};

let idCounter = 0;
class EmbeddedSandbox {
  constructor(options) {
    var _a;

    this.options = options;
    this.validateOptions();
    this.handleRequest = (_a = this.options.handleRequest) !== null && _a !== void 0 ? _a : defaultHandleRequest({
      includeCookies: !!this.options.includeCookies
    });
    this.uniqueEmbedInstanceId = idCounter++;
    this.embeddedSandboxIFrameElement = this.injectEmbed();
    this.disposable = setupSandboxEmbedRelay({
      embeddedSandboxIFrameElement: this.embeddedSandboxIFrameElement,
      handleRequest: this.handleRequest
    });
  }

  dispose() {
    var _a; // remove the dom element


    (_a = document.getElementById(IFRAME_DOM_ID(this.uniqueEmbedInstanceId))) === null || _a === void 0 ? void 0 : _a.remove(); // remove the listener

    this.disposable.dispose();
  }

  injectEmbed() {
    var _a;

    let element;
    const {
      target
    } = this.options;
    const {
      document: initialDocument,
      variables,
      headers
    } = this.options.initialState || {};
    const queryParams = {
      endpoint: this.options.initialEndpoint,
      defaultDocument: initialDocument ? encodeURIComponent(initialDocument) : undefined,
      defaultVariables: variables ? encodeURIComponent(JSON.stringify(variables, null, 2)) : undefined,
      defaultHeaders: headers ? encodeURIComponent(JSON.stringify(headers)) : undefined,
      parentSupportsSubscriptions: true,
      version: packageJSON.version
    };
    const queryString = Object.entries(queryParams).filter(([_, value]) => value !== undefined).map(([key, value]) => `${key}=${value}`).join('&');

    if (typeof target === 'string') {
      element = (_a = document === null || document === void 0 ? void 0 : document.querySelector) === null || _a === void 0 ? void 0 : _a.call(document, target);
    } else {
      element = target;
    }

    const iframeElement = document.createElement('iframe');
    iframeElement.src = `${EMBEDDABLE_SANDBOX_URL}?${queryString}`;
    iframeElement.id = IFRAME_DOM_ID(this.uniqueEmbedInstanceId);
    iframeElement.setAttribute('style', 'height: 100%; width: 100%; border: none;');
    element === null || element === void 0 ? void 0 : element.appendChild(iframeElement);
    return iframeElement;
  }

  validateOptions() {
    if (!this.options.target) {
      throw new Error('"target" is required');
    }
  }

  updateSchemaInEmbed({
    schema
  }) {
    sendPostMessageToEmbed({
      message: {
        name: SCHEMA_RESPONSE,
        schema
      },
      embeddedIFrameElement: this.embeddedSandboxIFrameElement,
      embedUrl: EMBEDDABLE_SANDBOX_URL
    });
  }

}

exports.EmbeddedSandbox = EmbeddedSandbox;
